---
alwaysApply: true
---

# 実装計画書作成ルール

## 概要

このプロジェクトでは、新機能の実装や既存機能の大幅な修正を行う際に、実装計画書を作成してから開発を開始します。
実装計画書は、アーキテクチャの設計、モジュール間の依存関係の明確化、段階的な実装手順の策定を通じて、品質の高い開発を実現することを目的とします。

## 基本ルール

### 1. 実装計画書の作成条件

**必須作成:**
- 新機能の実装時
- 既存機能の大幅な修正時
- アーキテクチャの変更時
- 複数のファイルに影響する変更時

**作成不要:**
- 小規模なバグ修正
- 単純な設定変更
- ドキュメントのみの更新

### 2. 実装計画書の基本構成

**必須セクション:**
- 概要（背景・目的・既存活用）
- 現在の状況（既に実装済み・不足している機能）
- アーキテクチャ概要（全体図・依存関係図・データフロー図）
- 実装計画（段階的フェーズ構成）
- 実装詳細（具体的なコード例）
- ファイル構成
- 成功指標

**禁止事項:**
- 所要時間の記載
- バージョン表記
- 変更履歴
- スケジュール関連の記述

### 3. アーキテクチャ図の作成ルール

**必須図表:**
- **全体アーキテクチャ図**: システム全体の構造を視覚化
- **モジュール依存関係図**: モジュール間の依存関係を明確化
- **データフロー図**: データの流れをシーケンス図で表現
- **段階的実装ステップ図**: フェーズ構成を視覚化

**Mermaid図表の作成原則:**
- カラフルな図形を使用する場合は、テキスト色を黒（`color:#000000`）に設定
- 視認性を重視し、背景色とテキスト色のコントラストを確保
- 依存関係は明確に矢印で表現
- 新規作成・拡張・既存のモジュールを色分けして区別

**図表のスタイリング例:**
```mermaid
graph TD
    A["新規モジュール"] --> B["既存モジュール"]
    
    style A fill:#ffcdd2,stroke:#d32f2f,stroke-width:2px,color:#000000
    style B fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px,color:#000000
```

### 4. 段階的実装フェーズの構成

**各フェーズの構成:**
各フェーズは以下の手順を必ず踏むこと：

1. **実装**: コードの実装
2. **ユーザー動作確認**: 実装内容をユーザーが確認（必ず手を止める）
3. **型チェック**: TypeScriptの型エラーを確認・修正
4. **テスト作成**: 実装した機能のテストを作成
5. **再度の型チェック**: テスト追加後の型エラーを確認・修正
6. **リントエラー修正**: ESLintエラーを修正
7. **チェンジログの作成**: 各フェーズごとにチェンジログを作成する

**フェーズの命名規則:**
- 実装フェーズ: `フェーズ X.1: 機能名の実装`
- テストフェーズ: `フェーズ X.2: 機能名のテスト`

**フェーズ間の依存関係:**
- 前のフェーズが完了してから次のフェーズに進む
- 各フェーズ完了時点で品質を保証する

### 5. タスク管理の表記ルール

**未完了タスク:**
- 半角角括弧で空のチェックボックスを使用
- 例: `[ ] 未実装のタスク1`

**完了タスク:**
- 絵文字のチェックボックスを使用
- 例: `✅ 完了したタスク1`

**タスクの記述例:**
```markdown
**確認ポイント:**
- [ ] 認証済みユーザーのみアクセス可能
- [ ] 適切なバリデーション
- [ ] データベース更新が正常に動作
- [ ] エラーハンドリング
- ✅ Hono RPCクライアントで正常に呼び出し可能
```

## 実装計画書の作成手順

### 1. 現状分析
- 既に実装済みの機能を確認
- 不足している機能を特定
- 技術スタックの確認
- 既存コードの活用可能性を検討

### 2. アーキテクチャ設計
- システム全体の構造を設計
- モジュール間の依存関係を明確化
- データフローを設計
- Mermaid図表でアーキテクチャを視覚化

### 3. 段階的実装計画
- 機能を小さな単位に分割
- 依存関係を考慮した実装順序を決定
- 各フェーズでの完了条件を設定
- 実装→確認→テストのサイクルを設計

### 4. ファイル構成の設計
- 作成・変更するファイルを特定
- ディレクトリ構造を設計
- インポート・エクスポート関係を整理
- 依存関係マトリクスを作成

### 5. 実装詳細の記述
- 具体的なコード例を記載
- API設計を明確化
- コンポーネント設計を詳細化
- テストケースの設計

## 実装フェーズの実行ルール

### フェーズ実行の基本フロー

各フェーズでは以下の手順を必ず実行すること：

```mermaid
graph LR
    A[実装] --> B[ユーザー動作確認]
    B --> C[型チェック]
    C --> D[テスト作成]
    D --> E[再度の型チェック]
    E --> F[リントエラー修正]
    F --> G[次のフェーズへ]
    
    style A fill:#c8e6c9,stroke:#4caf50,stroke-width:2px,color:#000000
    style B fill:#fff9c4,stroke:#f57f17,stroke-width:2px,color:#000000
    style C fill:#e1bee7,stroke:#7b1fa2,stroke-width:2px,color:#000000
    style D fill:#f8bbd0,stroke:#e91e63,stroke-width:2px,color:#000000
    style E fill:#e1bee7,stroke:#7b1fa2,stroke-width:2px,color:#000000
    style F fill:#ffcdd2,stroke:#d32f2f,stroke-width:2px,color:#000000
    style G fill:#b2ebf2,stroke:#0288d1,stroke-width:2px,color:#000000
```

### 各ステップの詳細

#### 1. 実装
- 計画書に基づいてコードを実装
- TSDoc形式のコメントを記述
- エラーハンドリングを適切に実装

#### 2. ユーザー動作確認
- **必ず手を止めて**実装内容をユーザーに報告
- 実装した機能の動作確認を依頼
- 問題があれば修正してから次に進む

#### 3. 型チェック
```bash
yarn tsc --noEmit
```
- TypeScriptの型エラーを確認
- エラーがあれば修正

#### 4. テスト作成
- 実装した機能のテストを作成
- 正常系・異常系の両方をカバー
- テストカバレッジを確認

#### 5. 再度の型チェック
```bash
yarn tsc --noEmit
```
- テスト追加後の型エラーを確認
- エラーがあれば修正

#### 6. リントエラー修正
```bash
yarn lint
```
- ESLintエラーを確認・修正
- Prettierフォーマットを適用

#### 7. チェンジログ作成
- 実装した内容のチェンジログを作成
- チェンジログ作成時のルールは `cursor/rules/documents/change-log.mdc`を参照

## 品質保証

### フェーズ完了条件の設定

各フェーズには以下のような完了条件を設定する：

```markdown
**✅ フェーズ X完了条件**: 
- 実装が完了していること
- ユーザーの動作確認が完了していること
- 型エラーが0件であること
- テストが全てパスしていること
- リントエラーが0件であること
```

### 最終完了条件

全てのフェーズ完了後：

```markdown
**✅ 実装完了条件**:
- 全てのフェーズが完了していること
- 成功指標を満たしていること
- ドキュメントが更新されていること
```

## 実装計画書の管理

### ファイル配置
- 実装計画書は `docs/implementation-plan/` ディレクトリに配置
- ファイル名は `{機能名}-implementation-plan.md` の形式

## 参考資料

- [プラン制限管理機能実装計画書](../../docs/implementation-plan/plan-limit-management-implementation-plan.md) - 実装計画書のモデルケース
- [プロジェクトのコーディング規約](../.cursor/rules/frontend.mdc) - フロントエンド開発ルール
- [テストファイル作成ルール](../.cursor/rules/testing.mdc) - テスト実装ルール

